MySQL 
逻辑架构
  第一层:服务层 为客户端服务，为请求做连接处理，授权认证，安全等
  第二层:核心服务层 主要提供查询解析，优化，缓存，重写查询，决定表的读取顺序以及选择合适的索引
  第三层:存储引擎层 负责数据的存储和读取
并发控制
  1.读写锁
     读锁:共享，互不阻塞，即多个用户同一时刻读统一资源，互不干扰
     写锁:排他，一个写锁会阻塞其他的读和写，安全策略保证只有这样才能保证同一时刻只有一个用户能写入，并防止
          其他用户读取正在写入的同一资源，避免脏读
  2.锁粒度
     表锁:整张表锁定，mysql中最基本的锁策略，是开销最小的策略，加锁之后整张表数据受到影响，不利于并发，写锁优先级高于读锁，写锁请求
          可能会被插入到读锁的队列前面。eg:alter table
     行锁:支持高并发，带来最大的锁开销。存储引擎实现
事务:ACID
  A:原子性 不可分割的单元
  C:一致性 执行事务之前数据库是一致的，那么执行事务之后数据库也是一致的
  I:隔离性 事务彼此间没有影响，在最终提交前对其他事务不可见
  D:持久性 事务提交后数据永久保存到数据库
  自动提交
隔离性
  READ_UNCOMMITED
  READ_COMMITED
  Repeatable_read(mysql默认隔离级别)
  Serializable
MVCC(多版本并发控制)：乐观并发和悲观并发
  通过在每行记录后加2个隐藏列(创建版本，过期版本)
  Repeatable_read级别下，MVCC操作如下：
  select：返回版本号早于当前事务版本的数据行(创建版本<=当前版本 & 删除版本>=当前版本)
  insert: 插入新行的时候，将事务分配到的版本号赋给创建版本那个列索性
  delete: 将版本号赋给删除版本号的那个列属性
  update: 实际上是新插入一条数据，将事务版本号赋给旧记录的删除版本号以及新纪录的创建版本号

多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免脏读等数据不一致的问题。后来的事务可以操作其他行数据，
解决了表锁高并发性能低的问题。
InnoDB只有通过索引条件检索数据时使用行级锁，否则使用表锁！
InNoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则会升级会表锁

行锁劣势 :开销大，加锁慢，会出现死锁
    优势:锁的粒度小，发生锁冲突的概率低，处理并发能力强
表锁优势: 开销小，加锁块，无死锁
    劣势: 锁粒度大，发生锁冲突的概率大，并发处理能力差
    
什么场景下用表锁
    默认使用行锁，未使用索引字段查询是升级为表锁。
    第一种:全表更新
    第二种:多表查询，避免死锁

页锁:介于行锁和表锁之间

可以使用explain执行计划查询索引是否被实际使用
    

  
     


表锁和行锁：
https://juejin.im/entry/5a55c7976fb9a01cba42786f
https://www.jianshu.com/p/1f17a496f14e

红黑数：https://blog.csdn.net/bytxl/article/details/40920165
