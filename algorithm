算法：
    执行效率和内存消耗
    稳定性：值相等，排序前后相对位置是否发生变化

排序算法：     平均      最好    最坏     空间
插入排序                     
    直接插入   O(n^2)    O(n)   O(n^2)   O(1)  稳定
    shell     O(n^2)    O(n)   O(n^2)   O(1)  不稳定
选择排序
    直接选择   O(n^2)    O(n^2)   O(n^2)   O(1)  不稳定
    堆排序     O(nlgn)   O(nlgn)   O(nlgn)  O(1)  不稳定
交换排序 
    冒泡排序   O(n^2)    O(n)    O(n^2)   O(1)    稳定
    快速排序   O(nlgn)   O(nlgn)  O(n^2)  O(1)    不稳定
快速排序是基于比较的内部排序中最好排序方法

线性时间的排序 时间复杂度O(n)
桶排序：输入数据必须仅由小于M的正整数组成
计数排序：特殊桶排序，桶粒度不同
基数排序：将字符串排序，手机号排序。。  每个位置进行桶排序，稳定排序

链表操作：
1.单链表的反转(第3个结点开始插入，最后把第一个结点放到最后)
2.链表中环的监测(1.快慢指针法  2.遍历全部，结合散列表)
3.2个有序链表的合并(递归，注意其中一个未null的判断)
4.删除链表中倒数第N个节点(快慢指针法)
5.求链表的中间节点(快慢指针法)

递归：f(n) = f(n-1) + 1
    条件：1.一个问题的解可分解成多个小问题的解
         2.分解后的问题思路一致
         3.存在递归终止条件

队列：
    循环队列：队列满判断 （tail + 1）% n = head



m阶B树和B+树的差别
1)B+树中具有n个关键字的结点有n个分支，而在B树中，具有n个关键字的结点含有n+1个分支
2)B+树中，每个结点中的关键字个数取值为ceil（m/2）<=n <= m， 根结点的取值范围为1<=n<=m。
3)B+树中叶子结点包含信息，并且包含了全部关键字,叶子结点引出的指针指向记录
4)B+树中所有非叶子结点仅起到一个索引的作用，即结点中的每个索引项只含有对应字数的最大关键字和指向该子树
  的指针，不含有该关键字对应记录的存储地址，而在B树中，每个关键字对应一个记录的存储地址
